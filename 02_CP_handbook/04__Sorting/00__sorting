Sorting is a fundamental algorithm design problem.


There are many algorithms for sorting, and they are also good examples of
how to apply different algorithm design techniques. The efficient general sorting
algorithms work in O(nlogn) time, and many algorithms that use sorting as a
subroutine also have this time complexity.


**Sorting Theory:
=================
Given an array that contains n elements, your task is to sort the elements in
increasing order.

For example, the array
1 3 8 2 9 2 5 6

will be as follows after sorting:
1 2 2 3 5 6 8 9


There are So many algorithms for sorting some of them are:
1. Bubble Sort
2. Selection Sort
3. Insertion Sort
4. Merge Sort
5. Quick Sort
6. Radix Sort
===========================================================================================

1. Bubble Sort:
Time complexity of Bubble sort is O(n^2).
In bubble sort we perform n-1 iterations for n numbers and with every iteration we move 
the greatest number at its extreme right this element is known as bubble.
With every iteration our problem get reduced by 1 element from right side.

--------------------------------------------------------------------------------------------

2. Selection Sort:
Selection sort has a time complexity of O(n^2).
In selection sort we pick the smallest element from an array and place it at its appropriate position.
After every iteration the problem get reduced by one from left hand side.

The no. of swaps required in selection sort are less then the no. of swaps required in bubble sort.
So selection sort is more effecient than bubble sort. Due to the no. of swaps required.

-----------------------------------------------------------------------------------------------

3. Insertion Sort:
Time complecity of Insertion sort is O(n^2).
In insertion sort we devide array in two parts. We consider the left part of an array is sorted part
and right part of an array is unsorted part. In each iteration we pick the first element from right hand side and move it 
into a left hand side at its appropriate position using displacement. In this way the unsorted list start to 
reduce by one with each iteration.

------------------------------------------------------------------------------------------------

4. Merge Sort:
Time compexity for Merge sort is O(nlog(n)) but for worst case it is O(n^2).
Merge sort will work on the divide and conqure strategy. There are two routines of recursion in
Merge sort known as divide and other is merge. In divide routine we divide our problem into small
parts from the middle of an array. When we reach at only 1 element then that element is considered as 
already sorted and then we start to merge the two conscutive sorted arrays.
Merge sort require extra space for temprory array that is why it has more space compexity than any other
sorting technique but it is effecient according to time but only when there is not an worst case.

